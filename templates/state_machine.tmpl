// Code generated by gofsm-gen. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"sync"
)

// {{.Name}}State represents all possible states
type {{.Name}}State int

//exhaustive:enforce
const (
{{- range $i, $state := .States}}
	{{$.Name}}State{{$state.Name | title}} {{$.Name}}State = {{$i}}
{{- end}}
)

// String returns the string representation of the state
func (s {{.Name}}State) String() string {
	//exhaustive:enforce
	switch s {
{{- range .States}}
	case {{$.Name}}State{{.Name | title}}:
		return "{{.Name}}"
{{- end}}
	default:
		return fmt.Sprintf("Unknown{{$.Name}}State(%d)", s)
	}
}

// {{.Name}}Event represents all possible events
type {{.Name}}Event int

//exhaustive:enforce
const (
{{- range $i, $event := .Events}}
	{{$.Name}}Event{{$event.Name | title}} {{$.Name}}Event = {{$i}}
{{- end}}
)

// String returns the string representation of the event
func (s {{.Name}}Event) String() string {
	//exhaustive:enforce
	switch s {
{{- range .Events}}
	case {{$.Name}}Event{{.Name | title}}:
		return "{{.Name}}"
{{- end}}
	default:
		return fmt.Sprintf("Unknown{{$.Name}}Event(%d)", s)
	}
}

// {{.Name}}Context is the context passed through state transitions
type {{.Name}}Context struct {
	// Add your custom fields here
}

// {{.Name}}Guards contains all guard functions
type {{.Name}}Guards struct {
{{- range .Transitions}}
{{- if .Guard}}
	{{.Guard | title}} func(ctx context.Context, c *{{$.Name}}Context) bool
{{- end}}
{{- end}}
}

// {{.Name}}Actions contains all action functions
type {{.Name}}Actions struct {
{{- range .Transitions}}
{{- if .Action}}
	{{.Action | title}} func(ctx context.Context, from, to {{$.Name}}State, c *{{$.Name}}Context) error
{{- end}}
{{- end}}
}

// {{.Name}}EntryActions contains all state entry actions
type {{.Name}}EntryActions struct {
{{- range .States}}
{{- if .EntryAction}}
	{{.EntryAction | title}} func(ctx context.Context, c *{{$.Name}}Context) error
{{- end}}
{{- end}}
}

// {{.Name}}ExitActions contains all state exit actions
type {{.Name}}ExitActions struct {
{{- range .States}}
{{- if .ExitAction}}
	{{.ExitAction | title}} func(ctx context.Context, c *{{$.Name}}Context) error
{{- end}}
{{- end}}
}

// {{.Name}}Option is a functional option for configuring the state machine
type {{.Name}}Option func(*{{.Name}})

// WithLogger sets a custom logger for the state machine
func WithLogger(logger Logger) {{.Name}}Option {
	return func(sm *{{.Name}}) {
		sm.logger = logger
	}
}

// WithValidationMode enables strict validation mode
func WithValidationMode(enabled bool) {{.Name}}Option {
	return func(sm *{{.Name}}) {
		sm.validationMode = enabled
	}
}

// WithZeroAllocation enables zero-allocation mode for performance
func WithZeroAllocation(enabled bool) {{.Name}}Option {
	return func(sm *{{.Name}}) {
		sm.zeroAllocation = enabled
	}
}

// Logger interface for state machine logging
type Logger interface {
	Info(msg string, args ...interface{})
	Error(msg string, args ...interface{})
	Debug(msg string, args ...interface{})
}

// {{.Name}} is the generated state machine
type {{.Name}} struct {
	mu              sync.RWMutex
	currentState    {{.Name}}State
	context         *{{.Name}}Context
	guards          {{.Name}}Guards
	actions         {{.Name}}Actions
	entryActions    {{.Name}}EntryActions
	exitActions     {{.Name}}ExitActions
	logger          Logger
	validationMode  bool
	zeroAllocation  bool
}

// New{{.Name}} creates a new state machine instance
func New{{.Name}}(
	guards {{.Name}}Guards,
	actions {{.Name}}Actions,
	opts ...{{.Name}}Option,
) *{{.Name}} {
	sm := &{{.Name}}{
		currentState: {{.Name}}State{{.Initial | title}},
		context:      &{{.Name}}Context{},
		guards:       guards,
		actions:      actions,
		logger:       &noopLogger{},
	}

	for _, opt := range opts {
		opt(sm)
	}

	return sm
}

// State returns the current state
func (sm *{{.Name}}) State() {{.Name}}State {
	sm.mu.RLock()
	defer sm.mu.RUnlock()
	return sm.currentState
}

// Context returns the state machine context
func (sm *{{.Name}}) Context() *{{.Name}}Context {
	sm.mu.RLock()
	defer sm.mu.RUnlock()
	return sm.context
}

// SetContext updates the state machine context
func (sm *{{.Name}}) SetContext(ctx *{{.Name}}Context) {
	sm.mu.Lock()
	defer sm.mu.Unlock()
	sm.context = ctx
}

// Transition triggers a state transition
func (sm *{{.Name}}) Transition(ctx context.Context, event {{.Name}}Event) error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	currentState := sm.currentState
	sm.logger.Debug("Attempting transition", "from", currentState, "event", event)

	// Find valid transition based on current state and event
	//exhaustive:enforce
	switch currentState {
{{- range .States}}
	case {{$.Name}}State{{.Name | title}}:
		{{- $currentState := .Name}}
		{{- $transitions := $.GetTransitionsFrom .Name}}
		{{- if $transitions}}
		//exhaustive:enforce
		switch event {
		{{- range $transitions}}
		case {{$.Name}}Event{{.Event | title}}:
			{{- $targetState := .To}}
			{{- if .Guard}}
			// Check guard condition
			if sm.guards.{{.Guard | title}} != nil && !sm.guards.{{.Guard | title}}(ctx, sm.context) {
				return fmt.Errorf("guard condition failed for transition from %s on %s", currentState, event)
			}
			{{- end}}

			{{- $exitAction := ""}}
			{{- range $.States}}
				{{- if eq .Name $currentState}}
					{{- $exitAction = .ExitAction}}
				{{- end}}
			{{- end}}
			{{- if $exitAction}}
			// Execute exit action
			if sm.exitActions.{{$exitAction | title}} != nil {
				if err := sm.exitActions.{{$exitAction | title}}(ctx, sm.context); err != nil {
					return fmt.Errorf("exit action failed: %w", err)
				}
			}
			{{- end}}

			{{- if .Action}}
			// Execute transition action
			if sm.actions.{{.Action | title}} != nil {
				if err := sm.actions.{{.Action | title}}(ctx, currentState, {{$.Name}}State{{$targetState | title}}, sm.context); err != nil {
					return fmt.Errorf("transition action failed: %w", err)
				}
			}
			{{- end}}

			// Update state
			sm.currentState = {{$.Name}}State{{$targetState | title}}
			sm.logger.Info("State transition completed", "from", currentState, "to", sm.currentState, "event", event)

			{{- $entryAction := ""}}
			{{- range $.States}}
				{{- if eq .Name $targetState}}
					{{- $entryAction = .EntryAction}}
				{{- end}}
			{{- end}}
			{{- if $entryAction}}
			// Execute entry action
			if sm.entryActions.{{$entryAction | title}} != nil {
				if err := sm.entryActions.{{$entryAction | title}}(ctx, sm.context); err != nil {
					return fmt.Errorf("entry action failed: %w", err)
				}
			}
			{{- end}}

			return nil
		{{- end}}
		default:
			return fmt.Errorf("invalid event %s for state %s", event, currentState)
		}
		{{- else}}
		return fmt.Errorf("no transitions defined from state %s", currentState)
		{{- end}}
{{- end}}
	default:
		return fmt.Errorf("unknown state: %s", currentState)
	}
}

// PermittedEvents returns all events that can be triggered from the current state
func (sm *{{.Name}}) PermittedEvents() []{{.Name}}Event {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	var events []{{.Name}}Event

	//exhaustive:enforce
	switch sm.currentState {
{{- range .States}}
	case {{$.Name}}State{{.Name | title}}:
		{{- $transitions := $.GetTransitionsFrom .Name}}
		{{- if $transitions}}
		events = []{{$.Name}}Event{
		{{- range $transitions}}
			{{$.Name}}Event{{.Event | title}},
		{{- end}}
		}
		{{- end}}
{{- end}}
	}

	return events
}

// CanTransition checks if a transition is possible without executing it
func (sm *{{.Name}}) CanTransition(ctx context.Context, event {{.Name}}Event) bool {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	currentState := sm.currentState

	//exhaustive:enforce
	switch currentState {
{{- range .States}}
	case {{$.Name}}State{{.Name | title}}:
		{{- $transitions := $.GetTransitionsFrom .Name}}
		{{- if $transitions}}
		//exhaustive:enforce
		switch event {
		{{- range $transitions}}
		case {{$.Name}}Event{{.Event | title}}:
			{{- if .Guard}}
			// Check guard condition
			if sm.guards.{{.Guard | title}} != nil {
				return sm.guards.{{.Guard | title}}(ctx, sm.context)
			}
			{{- end}}
			return true
		{{- end}}
		default:
			return false
		}
		{{- else}}
		return false
		{{- end}}
{{- end}}
	default:
		return false
	}
}

// noopLogger is a no-op logger implementation
type noopLogger struct{}

func (l *noopLogger) Info(msg string, args ...interface{})  {}
func (l *noopLogger) Error(msg string, args ...interface{}) {}
func (l *noopLogger) Debug(msg string, args ...interface{}) {}
